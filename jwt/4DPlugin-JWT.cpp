/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-JWT.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : JWT
 #	author : miyako
 #	2020/04/15
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-JWT.h"

#pragma mark -

long long int getlld(C_TEXT &Param)
{
    if(Param.getUTF16Length())
    {
        CUTF8String num;
        Param.copyUTF8String(&num);
        char *end;
        return strtoll((const char *)num.c_str(), &end, 10);
    }
    
    return 0;
}

long long int getlld(std::string &num)
{
    if(num.length())
    {
        char *end;
        return strtoll(num.c_str(), &end, 10);
    }
    
    return 0;
}

void convertFromString(std::string &fromString, C_TEXT &toString)
{
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), (LPWSTR)&buf[0], len)){
            CUTF16String u16 = CUTF16String((const PA_Unichar *)&buf[0]);
            toString.setUTF16String(&u16);
        }
    }else{
        CUTF16String u16 = CUTF16String((const PA_Unichar *)L"\0\0");
        toString.setUTF16String(&u16);
    }
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)fromString.c_str(), fromString.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        CUTF16String u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        toString.setUTF16String(&u16);
        CFRelease(str);
    }
#endif
}

void convertToString(C_TEXT &fromString, std::string &toString)
{
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), (LPSTR)&buf[0], len, NULL, NULL)){
            toString = std::string((const char *)&buf[0]);
        }
    }else{
        toString = std::string((const char *)"\0");
    }
#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)fromString.getUTF16StringPtr(), fromString.getUTF16Length());
    if(str){
        
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        
        toString = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
                // --- JWT
                
            case 1 :
                JWT_Timestamp(params);
                break;
            case 2 :
                JWT_Sign(params);
                break;
            case 3 :
                JWT_Verify(params);
                break;
                
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark -

void JWT_Timestamp(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    long long int time_1 = getlld(Param1);
    long long int time_2 = getlld(Param2);
    
    if(time_1 == 0)
    {
#if VERSIONWIN
        static const __int64 SECS_BETWEEN_1601_AND_1970_EPOCHS = 116444736000000000LL;
        FILETIME ft;
        GetSystemTimeAsFileTime(&ft);
        ULARGE_INTEGER ul;
        ul.LowPart = ft.dwLowDateTime;
        ul.HighPart = ft.dwHighDateTime;
        time_1 = (long long int)((ul.QuadPart - SECS_BETWEEN_1601_AND_1970_EPOCHS) / 10000);
#else
        struct timeb timer_msec;
//        long long int timestamp_msec;
        if (!ftime(&timer_msec))
        {
            time_1 = ((long long int) timer_msec.time) * 1000ll + (long long int) timer_msec.millitm;
        }
#endif
    }
    
    time_1 += time_2;
    
    std::vector<uint8_t>buf(100);
    int len = snprintf ( (char *)&buf[0], 100, "%lld", time_1);
    
    if(0 < len)
    {
        returnValue.setUTF8String((const uint8_t *)&buf[0], len);
    }
    
    returnValue.setReturn(pResult);
}

void JWT_Sign(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    using namespace Json;
    using namespace std;
    using namespace jwtpp;
    
    string header_json;
    convertToString(Param1, header_json);
    
    string payload_json ;
    convertToString(Param2, payload_json);
    
    string private_key;
    convertToString(Param3, private_key);
    
    Value root;
    CharReaderBuilder builder;
    string errors;
    
    CharReader *reader = builder.newCharReader();
    bool parse = reader->parse(payload_json.c_str(),
                               payload_json.c_str() + payload_json.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        for(Value::const_iterator it = root.begin() ; it != root.end() ; it++)
        {
            Value key = it.key();
            JSONCPP_STRING name = it.name();
            /* cast IntDate from string to int [exp,iat,nbf] */
            if((name == "exp") || (name == "iat") || (name == "nbf"))
            {
                if(it->isString())
                {
                    string value = it->asString();
                    root[name] = getlld(value);
                }
            }
        }
        /*
         adds an extra \n at the end; don't do it
         payload_json = root.toStyledString();
         */
        Json::StreamWriterBuilder builder;
        builder["indentation"] = "";
        payload_json = Json::writeString(builder, root);
        
    }
    
    reader = builder.newCharReader();
    parse = reader->parse(header_json.c_str(),
                          header_json.c_str() + header_json.size(),
                          &root,
                          &errors);
    delete reader;
    
    alg_t alg = alg_t::NONE;
    
    if(parse)
    {
        for(Value::const_iterator it = root.begin() ; it != root.end() ; it++)
        {
            Value key = it.key();
            JSONCPP_STRING name = it.name();
            
            if(name == "alg")
            {
                if(it->isString())
                {
                    string value = it->asString();
                    if(value == "HS256")
                    {
                        alg = alg_t::HS256;
                        break;
                    }
                    if(value == "HS384")
                    {
                        alg = alg_t::HS384;
                        break;
                    }
                    if(value == "HS512")
                    {
                        alg = alg_t::HS512;
                        break;
                    }
                    if(value == "RS256")
                    {
                        alg = alg_t::RS256;
                        break;
                    }
                    if(value == "RS384")
                    {
                        alg = alg_t::RS384;
                        break;
                    }
                    if(value == "RS512")
                    {
                        alg = alg_t::RS512;
                        break;
                    }
                    if(value == "ES256")
                    {
                        alg = alg_t::ES256;
                        break;
                    }
                    if(value == "ES384")
                    {
                        alg = alg_t::ES384;
                        break;
                    }
                    if(value == "ES512")
                    {
                        alg = alg_t::ES512;
                        break;
                    }
                    if(value == "UNKNOWN")
                    {
                        alg = alg_t::UNKNOWN;
                        break;
                    }
                }
            }
        }
        
        Json::StreamWriterBuilder builder;
        builder["indentation"] = "";
        header_json = Json::writeString(builder, root);
    }
    
    string bearer;
    
    try
    {
        jwtpp::claims claims(payload_json);
        
        BIO *bio = BIO_new_mem_buf((const void *)private_key.c_str(), (int)private_key.length());
        
        if(bio)
        {
            switch(alg)
            {
                case alg_t::ES256:
                case alg_t::ES384:
                case alg_t::ES512:
                {
                    EC_KEY *key = NULL;
                    key = PEM_read_bio_ECPrivateKey(bio, NULL, NULL, NULL);
                    
                    if(key)
                    {
                        if(EC_KEY_check_key(key) != 0)
                        {
                            std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)> ctx(EVP_MD_CTX_new(), EVP_MD_CTX_free);
                            
                            const EVP_MD *(*md)();
                            switch(alg)
                            {
                                case alg_t::ES384:
                                    md = EVP_sha384;
                                    break;
                                case alg_t::ES512:
                                    md = EVP_sha512;
                                    break;
                                case alg_t::ES256:
                                default:
                                    md = EVP_sha256;
                                    break;
                            }
                            
                            if(EVP_DigestInit(ctx.get(), md()) != 0)
                            {
                                string data;
                                string sign;
                                
                                data += base64_encode_uri((const unsigned char *)header_json.c_str(), header_json.size());
                                data += ".";
                                data += base64_encode_uri((const unsigned char *)payload_json.c_str(), payload_json.size());

                                if(EVP_DigestUpdate(ctx.get(), data.data(), data.size()) != 0)
                                {
                                    unsigned int len = 0;
                                    std::string hash;
                                    hash.resize(EVP_MD_CTX_size(ctx.get()));
                                    if(EVP_DigestFinal(ctx.get(), (unsigned char*)hash.data(), &len) != 0)
                                    {
                                        hash.resize(len);
                                        std::unique_ptr<ECDSA_SIG, decltype(&ECDSA_SIG_free)>
                                        sig(ECDSA_do_sign((const unsigned char *)hash.data(), (int)hash.size(), key), ECDSA_SIG_free);
                                        
                                        const BIGNUM *r;
                                        const BIGNUM *s;
                                        ECDSA_SIG_get0(sig.get(), &r, &s);
                                           
                                        vector<unsigned char > buf(BN_num_bytes(r) + BN_num_bytes(s));

                                        memset(&buf[0], 0, buf.size());
 
                                        BN_bn2bin(r, &buf[0]);
                                        BN_bn2bin(s, &buf[BN_num_bytes(r)]);
                                        
                                        sign = base64_encode_uri((const unsigned char *)&buf[0], buf.size());
                                                                                
                                        bearer = data + "." + sign;
                                        
                                    }
                                }
                            }
                        }
                        
                        EC_KEY_free(key);
                    }
                }
                    break;
                    
                case alg_t::HS256:
                case alg_t::HS384:
                case alg_t::HS512:
                {
                    std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)> ctx(EVP_MD_CTX_new(), EVP_MD_CTX_free);
                    
                    const EVP_MD *(*md)();
                    uint32_t hashlen;
                    
                    switch(alg)
                    {
                        case alg_t::HS384:
                            md = EVP_sha384;
                            hashlen = 48;
                            break;
                        case alg_t::HS512:
                            md = EVP_sha512;
                            hashlen = 64;
                            break;
                        case alg_t::HS256:
                        default:
                            md = EVP_sha256;
                            hashlen = 32;
                            break;
                    }
                                        
                    vector<unsigned char > buf(hashlen);
                    memset(&buf[0], 0, buf.size());
                    
                    string data;
                    string sign;
                    
                    data += base64_encode_uri((const unsigned char *)header_json.c_str(), header_json.size());
                    data += ".";
                    data += base64_encode_uri((const unsigned char *)payload_json.c_str(), payload_json.size());
                    
                    HMAC(md(),
                         (const void *)private_key.c_str(),
                         (int)private_key.length(),
                         (const unsigned char *)data.c_str(),
                         (int)data.length(),
                         (unsigned char *)&buf[0], &hashlen);
                    
                    sign = base64_encode_uri((const unsigned char *)&buf[0], hashlen);
                    
                    bearer = data + "." + sign;
  
                }
                    break;
                    
                default:
                {
                    RSA *key = NULL;
                    key = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);
                    if(key)
                    {
                                                
                        const EVP_MD *(*md)();
                        switch(alg)
                        {
                            case alg_t::RS384:
                                md = EVP_sha384;
                                break;
                            case alg_t::RS512:
                                md = EVP_sha512;
                                break;
                            case alg_t::RS256:
                            default:
                                md = EVP_sha256;
                                break;
                        }
                        
                        size_t hashlen = RSA_size(key);
                        
                        vector<unsigned char > buf(hashlen);
                        memset(&buf[0], 0, hashlen);
                        
                        string data;
                        string sign;
                        
                        data += base64_encode_uri((const unsigned char *)header_json.c_str(), header_json.size());
                        data += ".";
                        data += base64_encode_uri((const unsigned char *)payload_json.c_str(), payload_json.size());
                        
                        EVP_MD_CTX* ctx = EVP_MD_CTX_create();
                        EVP_PKEY* priKey  = EVP_PKEY_new();
                                        
                        EVP_PKEY_assign_RSA(priKey, key);/* do not need to release key */
                        
                        if (EVP_DigestSignInit(ctx,
                                               NULL,
                                               md(),
                                               NULL,
                                               priKey) != 0) {
                            
                            if (EVP_DigestSignUpdate(ctx,
                                                     (const unsigned char *)data.c_str(),
                                                     (unsigned int)data.length()) != 0) {
                                
                                
                                if (EVP_DigestSignFinal(ctx,
                                                        &buf[0],
                                                        &hashlen) != 0) {
                                    
                                    sign = base64_encode_uri((const unsigned char *)&buf[0], hashlen);
                                    
                                    bearer = data + "." + sign;
                                    
                                }
    
                            }
                            
                        }
                        
                        EVP_PKEY_free(priKey);
                        EVP_MD_CTX_free(ctx);

                    }
                    
                }
                    break;
            }
            BIO_free(bio);
        }
        
    }catch(...)
    {
        
    }
    
    convertFromString(bearer, returnValue);
    returnValue.setReturn(pResult);
    
}

static std::unique_ptr<BIGNUM, decltype(&BN_free)> raw2bn(const std::string& raw) {
    return std::unique_ptr<BIGNUM, decltype(&BN_free)>(BN_bin2bn((const unsigned char*)raw.data(), (int)raw.size(), nullptr), BN_free);
}

void JWT_Verify(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    using namespace Json;
    using namespace std;
    using namespace jwtpp;
    
    alg_t alg = alg_t::NONE;
    
    string bearer, payload, data, sign;
    
    std::vector<unsigned char>hash;
    
    convertToString(Param1, bearer);
    
    size_t pos = bearer.find(".");
    if(pos != string::npos)
    {
        string header = bearer.substr(0, pos);
        pos = header.find("Bearer ");
        
        if(pos != string::npos)
        {
            header = header.substr(pos + 7);
        }
        
        pos = bearer.find(".", ++pos);

        if(pos != string::npos)
        {
            size_t start = ++pos;
            pos = bearer.find(".", start);
            
            if(pos != string::npos)
            {
                size_t end = ++pos;
                payload = bearer.substr(start, end - start - 1);
                data = header + "." + payload;
                sign = bearer.substr(end);
                base64_decode_uri(hash, sign);
            }
        }
        
        std::vector<unsigned char>buf;
        
        base64_decode_uri(buf, header);
        
        std::string header_json = std::string((const char *)&buf[0]);
        
        Value root;
        CharReaderBuilder builder;
        string errors;
        
        CharReader *reader = builder.newCharReader();
        bool parse = reader->parse(header_json.c_str(),
                                   header_json.c_str() + header_json.size(),
                                   &root,
                                   &errors);
        delete reader;
        
        pos = bearer.find("Bearer ");
        
        if(pos == string::npos)
        {
            bearer = "Bearer " + bearer;
        }
        
        if(parse)
        {
            for(Value::const_iterator it = root.begin() ; it != root.end() ; it++)
            {
                Value key = it.key();
                JSONCPP_STRING name = it.name();
                
                if(name == "alg")
                {
                    if(it->isString())
                    {
                        string value = it->asString();
                        if(value == "HS256")
                        {
                            alg = alg_t::HS256;
                            break;
                        }
                        if(value == "HS384")
                        {
                            alg = alg_t::HS384;
                            break;
                        }
                        if(value == "HS512")
                        {
                            alg = alg_t::HS512;
                            break;
                        }
                        if(value == "RS256")
                        {
                            alg = alg_t::RS256;
                            break;
                        }
                        if(value == "RS384")
                        {
                            alg = alg_t::RS384;
                            break;
                        }
                        if(value == "RS512")
                        {
                            alg = alg_t::RS512;
                            break;
                        }
                        if(value == "ES256")
                        {
                            alg = alg_t::ES256;
                            break;
                        }
                        if(value == "ES384")
                        {
                            alg = alg_t::ES384;
                            break;
                        }
                        if(value == "ES512")
                        {
                            alg = alg_t::ES512;
                            break;
                        }
                        if(value == "UNKNOWN")
                        {
                            alg = alg_t::UNKNOWN;
                            break;
                        }
                    }
                }
            }
        }
    }
    
    string private_key;
    convertToString(Param2, private_key);
    
    try
    {
        BIO *bio = BIO_new_mem_buf((const void *)private_key.c_str(), (int)private_key.length());
        
        if(bio)
        {
            switch(alg)
            {
                case alg_t::ES256:
                case alg_t::ES384:
                case alg_t::ES512:
                {
                    EC_KEY *key = NULL;
                    key = PEM_read_bio_EC_PUBKEY(bio, NULL, NULL, NULL);
                    if(key)
                    {
                        const EVP_MD *(*md)();
                        switch(alg)
                        {
                            case alg_t::ES384:
                                md = EVP_sha384;
                                break;
                            case alg_t::ES512:
                                md = EVP_sha512;
                                break;
                            case alg_t::ES256:
                            default:
                                md = EVP_sha256;
                                break;
                        }
                        
                        std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)> ctx(EVP_MD_CTX_new(), EVP_MD_CTX_free);
                        
                        if(EVP_DigestInit(ctx.get(), md()) != 0)
                        {
                            if(EVP_DigestUpdate(ctx.get(), data.data(), data.size()) != 0)
                            {
                                unsigned int len = 0;
                                std::string dgst;
                                dgst.resize(EVP_MD_CTX_size(ctx.get()));
                                if(EVP_DigestFinal(ctx.get(), (unsigned char*)dgst.data(), &len) != 0)
                                {
                                    dgst.resize(len);
                                    
                                    std::unique_ptr<ECDSA_SIG, decltype(&ECDSA_SIG_free)> sig(ECDSA_SIG_new(), ECDSA_SIG_free);

                                    size_t hashlen = hash.size();

                                    int rlen = int(hashlen / 2);
                                    int slen = rlen;
                                    
                                    if(hashlen % 2 != 0) {
                                        
                                        hash.insert(hash.begin(), (unsigned char)0x0);
                                        slen++;
                                        rlen++;
                                    }
                                                                        
                                    std::unique_ptr<BIGNUM, decltype(&BN_free)> r(BN_bin2bn((const unsigned char*)&hash[0], rlen, nullptr), BN_free);
                                    std::unique_ptr<BIGNUM, decltype(&BN_free)> s(BN_bin2bn((const unsigned char*)&hash[rlen], slen, nullptr), BN_free);
                                    
                                    ECDSA_SIG_set0(sig.get(), r.release(), s.release());
                                    
                                    int verify = ECDSA_do_verify((const unsigned char *)dgst.data(), (int)dgst.size(), sig.get(), key);
                                    
                                    returnValue.setIntValue(verify);
                                    
                                }
                                
                            }
                            
                        }

                        EC_KEY_free(key);

                    }
   
                }
                    break;
                    
                case alg_t::HS256:
                case alg_t::HS384:
                case alg_t::HS512:
                {
                    std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)> ctx(EVP_MD_CTX_new(), EVP_MD_CTX_free);
                    
                    const EVP_MD *(*md)();
                    uint32_t hashlen;
                    
                    switch(alg)
                    {
                        case alg_t::HS384:
                            md = EVP_sha384;
                            hashlen = 48;
                            break;
                        case alg_t::HS512:
                            md = EVP_sha512;
                            hashlen = 64;
                            break;
                        case alg_t::HS256:
                        default:
                            md = EVP_sha256;
                            hashlen = 32;
                            break;
                    }
                    
                    vector<unsigned char > buf(hashlen);
                    memset(&buf[0], 0, buf.size());
                    
                    HMAC(md(),
                    (const void *)private_key.c_str(),
                    (int)private_key.length(),
                    (const unsigned char *)data.c_str(),
                    (int)data.length(),
                    (unsigned char *)&buf[0], &hashlen);
                    
                    int verify = (base64_encode_uri((const unsigned char *)&buf[0], hashlen) == sign);
                    
                    returnValue.setIntValue(verify);
                }
                    break;
                    
                default:
                {
                    RSA *key = NULL;
                    key = PEM_read_bio_RSA_PUBKEY(bio, NULL, NULL, NULL);
                    if(key)
                    {
                        const EVP_MD *(*md)();
                        switch(alg)
                        {
                            case alg_t::RS384:
                                md = EVP_sha384;
                                break;
                            case alg_t::RS512:
                                md = EVP_sha512;
                                break;
                            case alg_t::RS256:
                            default:
                                md = EVP_sha256;
                                break;
                        }
                        
                        EVP_PKEY* pubKey  = EVP_PKEY_new();
                        EVP_PKEY_assign_RSA(pubKey, key);
                        
                        EVP_MD_CTX* ctx = EVP_MD_CTX_create();
                        
                        if (EVP_DigestVerifyInit(ctx,
                                                 NULL,
                                                 md(),
                                                 NULL,
                                                 pubKey)!= 0) {
                            
                            if (EVP_DigestVerifyUpdate(ctx,
                                                       data.c_str(),
                                                       data.length()) != 0) {
                                
                                int verify = EVP_DigestVerifyFinal(ctx,
                                                                   (const unsigned char *)&hash[0],
                                                                   hash.size());
                                
                                returnValue.setIntValue(verify);
                            }
                            
                        }
                        
                        EVP_PKEY_free(pubKey);
                        EVP_MD_CTX_free(ctx);
                        
                    }
                    
                }
                    break;
            }
            BIO_free(bio);
        }
    }catch(...)
    {
        
    }
    
    returnValue.setReturn(pResult);
    
}

#pragma mark base64

/* Original source code taken from
 * https://svn.apache.org/repos/asf/apr/apr/trunk/encoding/apr_base64.c
 *
 * Changes by Michel Lang <michellang@gmail.com>:
 * - Replaced char 62 ('+') with '-'
 * - Replaced char 63 ('/') with '_'
 * - Removed padding with '=' at the end of the string
 * - Changed return type to void for Base64decode and Base64encode
 * - Added wrappers for R
 *
 */
/*
 * base64.c:  base64 encoding and decoding functions
 *
 * ====================================================================
 *    Licensed to the Apache Software Foundation (ASF) under one
 *    or more contributor license agreements.  See the NOTICE file
 *    distributed with this work for additional information
 *    regarding copyright ownership.  The ASF licenses this file
 *    to you under the Apache License, Version 2.0 (the
 *    "License"); you may not use this file except in compliance
 *    with the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing,
 *    software distributed under the License is distributed on an
 *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *    KIND, either express or implied.  See the License for the
 *    specific language governing permissions and limitations
 *    under the License.
 * ====================================================================
 */

#include <string.h>

static const unsigned char pr2six[256] = {
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 63,
    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 63,
    64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
};

static const char basis_64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

static int Base64decode_len(const char *bufcoded) {
    int nbytesdecoded;
    const unsigned char *bufin;
    int nprbytes;

    bufin = (const unsigned char *) bufcoded;
    while (pr2six[*(bufin++)] <= 63);

    nprbytes = (int)((bufin - (const unsigned char *) bufcoded) - 1);
    nbytesdecoded = ((nprbytes + 3) / 4) * 3;

    return nbytesdecoded + 1;
}

static int Base64encode_len(int len) {
    return ((len + 2) / 3 * 4) + 1;
}

static void Base64decode(std::vector<unsigned char>& decoded, const char *bufcoded) {
    const unsigned char *bufin;
    unsigned char *bufout;
    int nprbytes;

    bufin = (const unsigned char *) bufcoded;
    while (pr2six[*(bufin++)] <= 63);
    nprbytes = (int)((bufin - (const unsigned char *) bufcoded) - 1);

    unsigned char *bufplain = (unsigned char *) &decoded[0];
    bufout = bufplain;
    bufin = (const unsigned char *) bufcoded;

    while (nprbytes > 4) {
        *(bufout++) = (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) = (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) = (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if (nprbytes > 1)
        *(bufout++) = (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
    if (nprbytes > 2)
        *(bufout++) = (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
    if (nprbytes > 3)
        *(bufout++) = (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);

    decoded.resize(bufout - bufplain);
}

static void Base64encode(char *encoded, const char *string, int len) {
    int i;
    char *p = encoded;

    for (i = 0; i < len - 2; i += 3) {
        *p++ = basis_64[(string[i] >> 2) & 0x3F];
        *p++ = basis_64[((string[i] & 0x3) << 4) | ((int) (string[i + 1] & 0xF0) >> 4)];
        *p++ = basis_64[((string[i + 1] & 0xF) << 2) | ((int) (string[i + 2] & 0xC0) >> 6)];
        *p++ = basis_64[string[i + 2] & 0x3F];
    }

    if (i < len) {
        *p++ = basis_64[(string[i] >> 2) & 0x3F];
        if (i == (len - 1)) {
            *p++ = basis_64[((string[i] & 0x3) << 4)];
        } else {
            *p++ = basis_64[((string[i] & 0x3) << 4) | ((int) (string[i + 1] & 0xF0) >> 4)];
            *p++ = basis_64[((string[i + 1] & 0xF) << 2)];
        }
    }

    *p++ = '\0';
}

static std::string base64_encode_uri(const unsigned char *ptr, size_t size) {
        
    std::vector<char> encoded(Base64encode_len((int)size));
    
    Base64encode((char *)&encoded[0], (const char *)ptr, (int)size);
    
    return std::string((char *)&encoded[0]);
}

static void base64_decode_uri(std::vector<unsigned char>& decoded, std::string encoded) {
    
    decoded.resize(Base64decode_len((const char *)encoded.c_str()));
    
    Base64decode(decoded, (const char *)encoded.c_str());
}
